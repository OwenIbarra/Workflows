# Checks for the PKFail vulnerability.

<#
.SYNOPSIS
    Checks for the PKFail vulnerability.
.DESCRIPTION
    Checks the PK(Platform Key) variable for 'DO NOT TRUST' or 'DO NOT SHIP'.
    Can save a result of 'Trusted' or 'Not Trusted' to a custom field.

.EXAMPLE
    (No Parameters)

    Secure Boot is Trusted

.EXAMPLE
    (No Parameters)

    Secure Boot is Not Trusted

PARAMETER: -CustomField "ReplaceMeWithAnyMultilineCustomField"
    Name of a custom field to save the PKFail status to with either Trusted or Not Trusted.
.EXAMPLE
    -CustomField "SecureBootPK"

    Attempting to set Custom Field 'SecureBootPK'.
    Successfully set Custom Field 'SecureBootPK'!
    Secure Boot is Trusted

.NOTES
    Minimum OS Supported: Windows 10, Windows Server 2016

.LINK
    https://github.com/binarly-io/Vulnerability-REsearch/blob/main/PKfail/BRLY-2024-005.md
    https://www.intel.com/content/www/us/en/security-center/announcement/intel-security-announcement-2024-07-25-001.html
    https://www.supermicro.com/en/support/security_PKFAIL_Jul_2024
#>

[CmdletBinding()]
param (
    [Parameter()]
    [String]$CustomField
)

begin {
    function Set-NinjaProperty {
        [CmdletBinding()]
        Param(
            [Parameter(Mandatory = $True)]
            [String]$Name,
            [Parameter()]
            [String]$Type,
            [Parameter(Mandatory = $True, ValueFromPipeline = $True)]
            $Value,
            [Parameter()]
            [String]$DocumentName
        )
        
        $Characters = $Value | Out-String | Measure-Object -Character | Select-Object -ExpandProperty Characters
        if ($Characters -ge 200000) {
            throw [System.ArgumentOutOfRangeException]::New("Character limit exceeded: the value is greater than or equal to 200,000 characters.")
        }
            
        # If requested to set the field value for a Ninja document, specify it here.
        $DocumentationParams = @{}
        if ($DocumentName) { $DocumentationParams["DocumentName"] = $DocumentName }
            
        # This is a list of valid fields that can be set. If no type is specified, assume that the input does not need to be changed.
        $ValidFields = "Attachment", "Checkbox", "Date", "Date or Date Time", "Decimal", "Dropdown", "Email", "Integer", "IP Address", "MultiLine", "MultiSelect", "Phone", "Secure", "Text", "Time", "URL", "WYSIWYG"
        if ($Type -and $ValidFields -notcontains $Type) { Write-Warning "$Type is an invalid type. Please check here for valid types: https://ninjarmm.zendesk.com/hc/en-us/articles/16973443979789-Command-Line-Interface-CLI-Supported-Fields-and-Functionality" }
            
        # The field below requires additional information to set.
        $NeedsOptions = "Dropdown"
        if ($DocumentName) {
            if ($NeedsOptions -contains $Type) {
                # Redirect error output to the success stream to handle errors more easily if nothing is found or something else goes wrong.
                $NinjaPropertyOptions = Ninja-Property-Docs-Options -AttributeName $Name @DocumentationParams 2>&1
            }
        }
        else {
            if ($NeedsOptions -contains $Type) {
                $NinjaPropertyOptions = Ninja-Property-Options -Name $Name 2>&1
            }
        }
            
        # If an error is received with an exception property, exit the function with that error information.
        if ($NinjaPropertyOptions.Exception) { throw $NinjaPropertyOptions }
            
        # The types below require values not typically given to be set. The code below will convert whatever we're given into a format ninjarmm-cli supports.
        switch ($Type) {
            "Checkbox" {
                # Although it's highly likely we were given a value like "True" or a boolean data type, it's better to be safe than sorry.
                $NinjaValue = [System.Convert]::ToBoolean($Value)
            }
            "Date or Date Time" {
                # Ninjarmm-cli expects the GUID of the option to be selected. Therefore, match the given value with a GUID.
                $Date = (Get-Date $Value).ToUniversalTime()
                $TimeSpan = New-TimeSpan (Get-Date "1970-01-01 00:00:00") $Date
                $NinjaValue = $TimeSpan.TotalSeconds
            }
            "Dropdown" {
                # Ninjarmm-cli expects the GUID of the option we're trying to select, so match the value we were given with a GUID.
                $Options = $NinjaPropertyOptions -replace '=', ',' | ConvertFrom-Csv -Header "GUID", "Name"
                $Selection = $Options | Where-Object { $_.Name -eq $Value } | Select-Object -ExpandProperty GUID
            
                if (-not $Selection) {
                    throw [System.ArgumentOutOfRangeException]::New("Value is not present in dropdown options.")
                }
            
                $NinjaValue = $Selection
            }
            default {
                # All the other types shouldn't require additional work on the input.
                $NinjaValue = $Value
            }
        }
            
        # Set the field differently depending on whether it's a field in a Ninja Document or not.
        if ($DocumentName) {
            $CustomField = Ninja-Property-Docs-Set -AttributeName $Name -AttributeValue $NinjaValue @DocumentationParams 2>&1
        }
        else {
            $CustomField = $NinjaValue | Ninja-Property-Set-Piped -Name $Name 2>&1
        }
            
        if ($CustomField.Exception) {
            throw $CustomField
        }
    }

    if ($env:customFieldName -and $env:customFieldName -notlike "null") {
        $CustomField = $env:customFieldName
    }

    # Check if Secure Boot is supported on the system
    try {
        Get-SecureBootUEFI -Name PK -ErrorAction Stop | Out-Null
    }
    catch {
        if ($_.Exception.Message -like "*Cmdlet not supported on this platform*") {
            Write-Host "[Error] System does not support Secure Boot or is a BIOS (Non-UEFI) system."
            exit 1
        }
        elseif ($_.Exception.Message -like "*Variable is currently undefined*") {
            Write-Host "[Error] PK variable is not defined."
            exit 1
        }
    }

    function Test-IsElevated {
        $id = [System.Security.Principal.WindowsIdentity]::GetCurrent()
        $p = New-Object System.Security.Principal.WindowsPrincipal($id)
        $p.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)
    }

    if (-not (Test-IsElevated)) {
        Write-Host "[Error] Access Denied. Please run with Administrator privileges."
        exit 1
    }
}
process {

    # Secure Boot PK cert status
    try {
        if ([System.Text.Encoding]::ASCII.GetString((Get-SecureBootUEFI -Name PK).bytes) -match "DO NOT TRUST|DO NOT SHIP") {
            $SecureBootPK = "Not Trusted"
            Write-Host "[Alert] Secure Boot is $SecureBootPK"
        }
        else {
            $SecureBootPK = "Trusted"
            Write-Host "[Info] Secure Boot is $SecureBootPK"
        }
    }
    catch {
        Write-Host "[Error] Get-SecureBootUEFI return error: $($_.Exception.Message)"
        exit 1
    }

    if ($CustomField) {
        try {
            Write-Host "[Info] Attempting to set Custom Field '$CustomField'."
            Set-NinjaProperty -Name $CustomField -Value $SecureBootPK
            Write-Host "[Info] Successfully set Custom Field '$CustomField'!"
        }
        catch {
            Write-Host "[Warn] Failed to set Custom Field '$CustomField'."
            Write-Host "[Warn] $($_.Exception.Message)"
        }
    }
}
end {
    
    
    
}
